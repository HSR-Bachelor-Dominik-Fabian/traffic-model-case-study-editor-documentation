\chapter{Resultate}
\section{Performance}
Wie in Kapitel \ref{ch:NFRs} \nameref{ch:NFRs} beschrieben, ist die Performance eine der wichtigsten nicht-funktionalen Anforderungen. Dies hatte zur Folge, dass besonders viel Zeit in deren Optimierung investiert wurde. In Kapitel \ref{ch:performance} \nameref{ch:performance} wird genauer auf die durchgeführten Optimierungen eingegangen.\\
Grundsätzlich gab es drei verschiedene Stufen von Performance, die erreicht wurden. In diesem Kapitel werden diese drei Stufen genauer analysiert und beschrieben.
\subsubsection*{Stufe 1}
In der ersten Stufe, zu Beginn des Projektes, wurde das gesamte Verkehrsmodell-Netzwerk mittels einer einzigen Abfrage beim Öffnen der Applikation geladen. Dabei wurde mit dem öffentlichen Netzwerk von Santiago de Chile gearbeitet. Dies beinhaltet ca. 60'000 Datensätze. Gemäss Tests benötigte diese Abfrage im Durchschnitt ca. 6 Sekunden. Mittels dieser Vorgehensweise wäre es unmöglich gewesen, ein Netzwerk wie die Schweiz mit ca. 4 Millionen Datensätzen in dieser Applikation zu laden und anzuzeigen.
\subsubsection*{Stufe 2}
In der nächsten Stufe wurde der QuadTile Algorithmus von OpenStreetMap eingeführt. Dadurch wird nicht mehr das gesamte Verkehrsmodell-Netzwerk geladen, sondern die Daten in Bereiche aufgeteilt. In dieser Stufe war es bereits möglich mit den 4 Millionen Datensätzen aus dem Verkehrsmodell der Schweiz zu arbeiten. Obwohl die Antwortzeiten immer noch deutlich zu hoch waren, konnte das Anzeigen des Schweizer Verkehrsmodells gemeistert werden.\\
Folgende Zugriffszeiten wurden gemessen:\\[0.3cm]
\begin{tabular}{ l c l}
Zoomstufen 10 - 14 & => & 1 - 3 Sekunden \\
Zoomstufen 14 - 18 & => & 3 - 10 Sekunden \\ 
\end{tabular} 
\subsubsection*{Stufe 3}
In der dritten Stufe wurden besonders im Backend sehr viele Optimierungen vorgenommen. Sei dies das Client-seitiges Caching, das Verhindern vom erneuten Zeichnen einer Strasse beim Wechsel der Zoomstufe, der Einsatz einer speziellen Operator Klasse für den Index oder die absichtliche Redundanz in dem Datenmodell. Genauere Beschreibungen der einzelnen Optimierungen sind in Kapitel \ref{ch:performance} \nameref{ch:performance} zu finden. Alle diese Optimierungen zusammen führten dazu, dass die Applikation eine deutlich höhere Performance aufwies und dadurch die Bearbeitung der Schweizer Verkehrsmodells kein Problem mehr darstellte.\\
Folgende Zugriffszeiten wurden gemessen:\\[0.3cm]
\begin{tabular}{ l c l}
Zoomstufen 10 - 14 & => & 50 - 100 Millisekunden \\
Zoomstufen 14 - 18 & => & 100 - 300 Millisekunden \\ 
\end{tabular}\\[0.3cm]
Die daraus resultierte Performance erfüllt die Anforderungen und ermöglicht ein benutzerfreundliches Bearbeiten des Schweizer Verkehrsmodells. Dennoch entsprechen die geladenen Links und Nodes einer sehr grosse Datenmenge, zum Teil mehr als 10'000 Datensätze pro Anzeige. Das Rendering dieser Datenmenge benötigt eine gewisse Zeit und verzögert dadurch das Darstellen der Daten auf der Karte. Auf die Geschwindigkeit des Renderings des Browsers konnte jedoch kein Einfluss genommen werden.
\section{Rückblick Technologien}
\subsection*{Leaflet}
Für die Darstellung der Karte wird die Library Leaflet, in Verbindung mit D3.js, verwendet. Die Vorteile von Leaflet liegen in der Möglichkeit verschiedene Layer dynamisch zu erzeugen und übereinander anzuordnen. Leaflet besitzt auch die Möglichkeit GeoJSON zu interpretieren und in SVG Geometrien darzustellen. Nachteile sind die fehlende Touch-Optimierung, durch welche es schwer ist die Karte auf Mobile-Geräten zu verwenden. Weiter besitzt Leaflet keine native Möglichkeit GeoJSON Daten von einem Service über das Tile-System zu beziehen. Diese Möglichkeit musste mit dem Plugin Leaflet GeoJSON Tile Layer hinzugefügt werden.
\subsection*{Leaflet GeoJSON Tile Layer}
Dieses Plugin für Leaflet wird eingesetzt um mit dem Tile System GeoJSON Daten vom Service zu beziehen. Diese Daten werden dann von Leaflet interpretiert und als SVG Elemente gerendert. Die Stärke des Plugin ist das einfache Handling. Schwächen besitzt das Plugin in der Implementation, welche nicht in allen belangen perfekt ist und manuell nachgebessert werden musste (z.B. wurden bei Http 204 No Content, Daten erwartet, was dem Standard widerspricht). Das Plugin musste auch mit einer Duplikaten-Erkennung ausgestattet werden, da sonst Strassen mehrfach gezeichnet wurden.
\subsection*{AngularJS}
AngularJS wurde verwendet um die Daten der Formulare, sowie alle Menüs zu verwalten. Die Grösse von Angular ist eine seiner Stärken. Die vielen Funktionen, welche in einem Framework kombiniert sind, arbeiten gut miteinander. Durch die Modularisierung kann der Code sehr gut aufgeteilt werden. Jedoch bringt die Modularisierung auch Schwächen mit sich. Module besitzen einen Scope. Dieser beinhaltet Daten und Methoden welche erreichbar sind. Damit zwei Module zusammenarbeiten können, muss der Scope geteilt werden. Es ist jedoch nicht immer klar, welches Modul mit welchem Scope zur Zeit erreichbar ist. Dadurch ist die Fehlersuche zum Teil ziemlich schwierig.
\subsection*{Play Framework}
Das Play Framework bildet die Basis des SimMapEditors. Im Play Framework sind die Views eingetragen, welche die Single Page App aufbauen. Die Stärke von Play ist der eingebaute Netty Server. Dieser erlaubt ein einfaches Deployment, da die Software nicht bei jedem Build in ein Apache geladen werden muss, sondern direkt gestartet werden kann. Über funktionale Stärken / Schwächen kann keine fundierte Aussage gemacht werden, da für die Implementation des SimMapEditor vor allem Javascript verwendet wurde.
\subsection*{Dropwizard}
Dropwizard ist ein Paket aus verschiedenen Libraries zur Implementation von REST Services. Das Paket beinhaltet JAX-RS mit Jersey für die REST Funktionalitäten. Für das Erstellen von JSON wird Jackson eingebaut, sowie ein NettyServer für das Deployment. Dropwizard erlaubt es einem ohne grossen Aufwand ein lauffähigen und einfach deployable Webservice zu erstellen. Jersey und JAX-RS sind starke Libraries, welches einfach ermöglichen einen REST Service (Maturity Level 2) zu implementieren.
